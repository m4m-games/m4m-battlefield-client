{"bend_a.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nprecision lowp float;\nuniform lowp sampler2D _Tex;\nuniform lowp vec4 _Colr;\n\n//in-----------------------------\nin mediump vec2 _Tex_uv_TEXCOORD0;\n\n//------------------------------------\n\n\n\n//textureEtC1Mark\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nin lowp float factor;\n#endif\n\n\nout vec4 color;\nvoid main() \n{\n    lowp vec4 emission = vec4(.0,.0,.0,.0);\n\n    //----------------------------------------------------------\n    lowp vec4 tex = texture(_Tex, _Tex_uv_TEXCOORD0);\n    lowp vec3 finalColor = _Colr.a * (_Colr.rgb * tex.rgb * 2.0 );\n    emission = vec4(finalColor.rgb , (tex.a * _Colr.a));\n\n    #ifdef FOG\n        emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    \n    color = emission;\n}","bend_a.shader.json":"{\n    \"layer\": \"transparent\",\n    \"queue\":  0,\n    \"properties\": [\n          \"_Tex('MainTex',Texture)='white'{}\",\n          \"_Colr ('Tint Color', Color) = (0.5,0.5,0.5,1.0)\"\n      ],\n      \"passes\": {\n          \"base\": [\n            {\n              \"blendmode\": \"blend\",\n              \"showface\": \"all\",\n              \"zwrite\": \"off\",\n              \"vs\": \"bend_a\",\n              \"fs\": \"bend_a\"\n            }\n          ],\n          \"shadowgen\": [],  \n          \"bone\": [],\n          \"shadowuse\": []\n      }\n  }","bend_a.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec4 _glesVertex;\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Tex_ST;\n\n#ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\nout mediump vec2 _Tex_uv_TEXCOORD0;\n\nvoid main()\n{\n    _Tex_uv_TEXCOORD0 = _glesMultiTexCoord0.xy * _Tex_ST.xy + _Tex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    //----------------------------------------------------------\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","body3fluxzy1.fs.glsl":"#version 300 es\r\n\r\n#define FLUXAY_COLOR_SWITCH\r\n\r\nprecision lowp float;\r\n// uniform highp mat4 glstate_matrix_it_modelview;\r\nuniform highp mat4 glstate_matrix_view;\r\n\r\nuniform float glstate_timer;\r\nuniform highp sampler2D _MainTex;\r\nuniform highp sampler2D _BumpMap;\r\nuniform highp sampler2D _MaskTex;\r\nuniform highp sampler2D _MatCap;\r\nuniform highp sampler2D _MatCap2;\r\nuniform highp sampler2D _MatCap3;\r\nuniform highp sampler2D _FluxayTex;\r\nuniform highp sampler2D _FluxayTex2;\r\n\r\nuniform lowp vec4 _MatCapColor;\r\nuniform lowp vec4 _MatCap2Color;\r\nuniform lowp vec4 _MatCap3Color;\r\n\r\nuniform lowp float _Strength;\r\nuniform lowp float _Strength2;\r\nuniform lowp float _Strength3;\r\n\r\nuniform lowp vec4 _FluxayColor;\r\nuniform lowp vec4 _FluxayColor2;\r\n\r\n// uniform lowp vec4 _MainColor;\r\n// uniform lowp float _AlphaCut;\r\n\r\n//light\r\n\r\n//in--------------------------\r\nin mediump vec2 uv_TEXCOORD0;\r\nin mediump vec2 uv_FluxayTex_TEXCOORD2;\r\nin mediump vec2 uv_FluxayTex2_TEXCOORD3;\r\n\r\nin highp vec3 v_N;\r\nin highp mat3 TBNmat;\r\n\r\n// in highp vec3 tSpace0;\r\n// in highp vec3 tSpace1;\r\n// in highp vec3 tSpace2;\r\n\r\nin highp vec3 t;\r\n\r\n\r\n//---------------------------------\r\n\r\n//textureEtC1Mark\r\n\r\n//UnpackNormal----------------------\r\nvec3 UnpackNormal(vec4 normalPixel){\r\n    return normalPixel.xyz *2.0 -1.0;\r\n}\r\n//----------------------------------\r\n\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nin lowp float factor;\r\n#endif\r\n\r\nout vec4 color;\r\nvoid main()\r\n{\r\n    lowp vec4 basecolor = texture(_MainTex, uv_TEXCOORD0);\r\n    lowp vec4 tex = basecolor;\r\n    // if(basecolor.a < _AlphaCut)\r\n    //     discard;\r\n    // lowp vec4 fristColor=basecolor*_MainColor;\r\n    // lowp vec4 fristColor = basecolor;\r\n    // lowp vec4 emission = fristColor;\r\n    lowp vec4 emission = basecolor;\r\n\r\n    //材质 mask 纹理\r\n    lowp vec4 masktex = texture(_MaskTex , uv_TEXCOORD0);\r\n    //获得 normal 从 切线空间\r\n    lowp vec3 worldNorm = UnpackNormal(texture(_BumpMap, uv_TEXCOORD0));\r\n    //worldNorm 到 world 空间\r\n    worldNorm = normalize(TBNmat * worldNorm);\r\n    //emission = vec4(worldNorm , 1.0);\r\n    // emission = vec4(uv_TEXCOORD0,0,1.0);\r\n    // emission = vec4(t,1.0);\r\n\r\n\r\n    // mediump vec3 worldNorm;\r\n    // worldNorm.x = dot(tSpace0.xyz, normals);\r\n    // worldNorm.y = dot(tSpace1.xyz, normals);\r\n    // worldNorm.z = dot(tSpace2.xyz, normals);\r\n    // emission = vec4(worldNorm,1);\r\n\r\n    //normals 到 view 空间\r\n    worldNorm = (mat3(glstate_matrix_view) * worldNorm);\r\n    // worldNorm = (mat3(glstate_matrix_view) * v_N);\r\n    // emission = vec4(worldNorm,1);\r\n\r\n    mediump vec2 capCoord = worldNorm.xy;\r\n    lowp vec4 matcap1 = texture(_MatCap,  capCoord * 0.5 + 0.5)  * _MatCapColor  * _Strength;//* tex * _Strength;\r\n    lowp vec4 matcap2 = texture(_MatCap2, capCoord * 0.5 + 0.5)  * _MatCap2Color * _Strength2;\r\n    lowp vec4 matcap3 = texture(_MatCap3, capCoord * 0.5 + 0.5)  * _MatCap3Color * _Strength3;\r\n    \r\n    lowp vec4 mc = (matcap1 * (masktex.r * masktex.g) + matcap2 * (1.0 - masktex.r) + matcap3 * (1.0 - masktex.g)) * tex;\r\n\r\n    #ifdef FLUXAY_COLOR_SWITCH\r\n        //SetDunamicTime();\r\n\r\n        mediump vec4 fluax1 = vec4(.0,.0,.0,.0);\r\n        highp vec2 moveadd = (uv_TEXCOORD0 + glstate_timer * 2.0 * vec2(1.0,1.0));\r\n        mediump vec4 fluaytex = texture(_FluxayTex , uv_FluxayTex_TEXCOORD2);\r\n        mediump vec3 emissive = (fluaytex.rgb * _FluxayColor.rgb * 2.0 * (fluaytex.a * (1.0 - masktex.b) * _FluxayColor.a));\r\n        fluax1 = vec4(emissive,.0) * fluaytex.a * _FluxayColor.a;\r\n\r\n        mediump vec4 fluay2tex = texture(_FluxayTex2 , uv_FluxayTex2_TEXCOORD3);\r\n        mediump vec3 emissive2 = (fluay2tex.rgb * _FluxayColor2.rgb * 2.0 * (fluay2tex.a * (1.0 - masktex.g) * _FluxayColor2.a));\r\n        fluax1 += (vec4(emissive2,.0) * fluay2tex.a * _FluxayColor2.a);\r\n        fluax1.rgb = fluax1.rgb * mc.rgb;\r\n        mc = mc + fluax1;\r\n    #endif\r\n\r\n    emission = mc; \r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    color = emission;\r\n}","body3fluxzy1.shader.json":"{\n    \"layer\": \"geometry\",\n\n    \"properties\": [\n        \"_MatCapColor('Main Color', Color) = (1.0, 1.0, 1.0, 1.0)\",\n        \"_MatCap2Color('Main Color 2', Color) = (1.0, 1.0, 1.0, 1.0)\",\n        \"_MatCap3Color('Main Color 3', Color) = (1.0, 1.0, 1.0, 1.0)\",\n        \"_Strength('Strength_1', Range(0.0, 10.0)) = 3.0\",\n        \"_Strength2('Strength_2', Range(0.0, 10.0)) = 3.0\",\n        \"_Strength3('Strength_3', Range(0.0, 10.0)) = 3.0\",\n\n        \"_MainTex ('Base (RGB)', Texture) = 'white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_BumpMap ('Normal Map', Texture) = 'white'{}\",\t\t\t\n        \"_MaskTex ('Mask (RGB)', Texture) = 'white'{}\",\n\n        \"_MatCap ('MatCap (RGB)', Texture) = 'white'{}\",\n        \"_MatCap2 ('MatCap2 (RGB)', Texture) = 'white'{}\",\n        \"_MatCap3 ('MatCap3 (RGB)', Texture) = 'white'{}\",\n\n        \"_FluxayTex ('FluxayTex(流光纹理g)', Texture) = 'white'{}\",\n        \"_FluxayTex_ST('FluxayTex_ST',Vector) = (1,1,0,0)\",\n        \"_FluxayColor ('FluxayColor(流光颜色g)', Color) = (1,0,0,1)\",\n        \"_FluxayTex2('FluxayTex2(流光纹理b)', Texture) = 'white'{}\",\n        \"_FluxayTex2_ST('FluxayTex2_ST',Vector) = (1,1,0,0)\",\n        \"_FluxayColor2 ('FluxayColor2(流光颜色b)', Color) = (0.5,0.5,0.5,1)\"\n\n\n\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"body3fluxzy1\",\n                \"fs\": \"body3fluxzy1\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"body3fluxzy1\",\n                \"fs\": \"body3fluxzy1\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"body3fluxzy1\",\n                \"fs\": \"body3fluxzy1\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"body3fluxzy1\",\n                \"fs\": \"body3fluxzy1\"\n            }\n        ]\n    }\n}","body3fluxzy1.vs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec4 _glesVertex;\r\nlayout(location = 4) in mediump vec4 _glesMultiTexCoord0;\r\n// layout(location = 5) in mediump vec4 _glesMultiTexCoord1;\r\nlayout(location = 2) in highp vec3 _glesTangent;\t//w 被乘到了分量里 x = x*w , y = y*w , z = z*w , 且 w 被做了 +2 的偏移映射。\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nuniform mediump vec4 _FluxayTex_ST;\r\nuniform mediump vec4 _FluxayTex2_ST;\r\n//light\r\nlowp mat4 blendMat ;\r\nlayout(location = 1) in highp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_it_modelview;\r\nuniform highp mat4 glstate_matrix_modelview;\r\n\r\n\r\n//out--------------------------\r\nout mediump vec2 uv_TEXCOORD0;\r\nout mediump vec2 uv_FluxayTex_TEXCOORD2;\r\nout mediump vec2 uv_FluxayTex2_TEXCOORD3;\r\n\r\nout highp vec3 v_N;\r\nout highp mat3 TBNmat;\r\n\r\n// out highp vec3 tSpace0;\r\n// out highp vec3 tSpace1;\r\n// out highp vec3 tSpace2;\r\n\r\nout highp vec3 t;\r\n\r\n//获取 tangent 的 W 值\r\nlowp float tangentW(lowp vec3 _tangent){\r\n\treturn sqrt(_tangent.x * _tangent.x + _tangent.y * _tangent.y + _tangent.z * _tangent.z) - 2.0;\r\n}\r\n\r\n//---------------------------------\r\n\r\n//计算 TBN 矩阵-----------------\r\nmediump mat3 calTBNMatrix(highp mat4 _m_mat,lowp vec3 _normal,lowp vec3 _tangent)\r\n{\r\n\r\n    lowp vec3 normal = normalize(mat3(_m_mat) * normalize(_normal));\r\n    lowp vec3 tangent = normalize(mat3(_m_mat) * normalize(_tangent));\r\n    lowp vec3 binormal = cross( normal , tangent) * tangentW(_tangent);\r\n  \treturn mat3(tangent,binormal,normal);\r\n}\r\n//-----------------------------\r\n\r\nmediump vec3 UnityObjectToWorldNormal(mediump mat3 _m_mat,mediump vec3 _normal){\r\n\t return normalize(_m_mat * _normal);\r\n}\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nlayout(location = 6) in lowp vec4 _glesBlendIndex4;\r\nlayout(location = 7) in lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\thighp vec3 _n = vec3(.0,.0,.0);\r\n    //求世界空间法线\r\n    #ifdef SKIN\r\n    _n = normalize(mat3(blendMat) * _glesNormal);\r\n    #else\r\n    _n = _glesNormal;\r\n    #endif\r\n    lowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\r\n\tTBNmat = calTBNMatrix(glstate_matrix_model , _n , _glesTangent);\r\n\r\n\tv_N = normalmat * _n;\r\n}\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    uv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    uv_FluxayTex_TEXCOORD2 = _glesMultiTexCoord0.xy * _FluxayTex_ST.xy + _FluxayTex_ST.zw;\r\n    uv_FluxayTex2_TEXCOORD3 = _glesMultiTexCoord0.xy * _FluxayTex2_ST.xy + _FluxayTex2_ST.zw;\r\n\r\n    //----------------------------------------------------------\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n\r\n\t//t = normalize(_glesTangent);\r\n\r\n\t//mediump mat3 rotation = calTANGENT_SPACE_ROTATION(_glesNormal , _glesTangent);\r\n\t\r\n\r\n\t// highp mat4 itMat = glstate_matrix_it_modelview;\r\n\r\n\t// c0 = rotation * normalize(glstate_matrix_modelview[0].xyz);\r\n\t// c1 = rotation * normalize(glstate_matrix_modelview[1].xyz);\r\n\t// c0 = TBNmat * normalize(glstate_matrix_it_modelview[0].xyz);\r\n\t// c1 = TBNmat * normalize(glstate_matrix_it_modelview[1].xyz);\r\n\r\n\t\r\n\t// highp mat3 wMat = mat3(glstate_matrix_model);\r\n\t// highp vec3 worldNormal = UnityObjectToWorldNormal(wMat , _glesNormal);\r\n\t// highp vec3 worldTangent = wMat * _glesTangent;\r\n\t// highp vec3 worldBinormal = cross(worldNormal, worldTangent) ;\r\n\t// tSpace0 = vec3(worldTangent.x, worldBinormal.x, worldNormal.x);\r\n\t// tSpace1 = vec3(worldTangent.y, worldBinormal.y, worldNormal.y);\r\n\t// tSpace2 = vec3(worldTangent.z, worldBinormal.z, worldNormal.z);\r\n\r\n\r\n    \r\n\tposition = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","bodyfluxzy2.fs.glsl":"#version 300 es\r\n\r\n#define FLUXAY_COLOR_SWITCH\r\n\r\nprecision lowp float;\r\n// uniform highp mat4 glstate_matrix_it_modelview;\r\nuniform highp mat4 glstate_matrix_view;\r\n\r\nuniform float glstate_timer;\r\nuniform highp sampler2D _MainTex;\r\nuniform highp sampler2D _BumpMap;\r\nuniform highp sampler2D _MaskTex;\r\nuniform highp sampler2D _MatCap;\r\nuniform highp sampler2D _MatCap2;\r\nuniform highp sampler2D _FluxayTex;\r\nuniform highp sampler2D _FluxayTex2;\r\n\r\nuniform lowp vec4 _MatCapColor;\r\nuniform lowp vec4 _MatCap2Color;\r\n\r\nuniform lowp float _Strength;\r\nuniform lowp float _Strength2;\r\n\r\nuniform lowp vec4 _FluxayColor;\r\nuniform lowp vec4 _FluxayColor2;\r\n\r\n// uniform lowp vec4 _MainColor;\r\n// uniform lowp float _AlphaCut;\r\n\r\n//light\r\n\r\n//in--------------------------\r\nin mediump vec2 uv_TEXCOORD0;\r\nin mediump vec2 uv_FluxayTex_TEXCOORD2;\r\nin mediump vec2 uv_FluxayTex2_TEXCOORD3;\r\n\r\nin highp mat3 TBNmat;\r\n\r\n// in highp vec3 tSpace0;\r\n// in highp vec3 tSpace1;\r\n// in highp vec3 tSpace2;\r\n\r\nin highp vec3 t;\r\n\r\n\r\n//---------------------------------\r\n\r\n//textureEtC1Mark\r\n\r\n//UnpackNormal----------------------\r\nvec3 UnpackNormal(vec4 normalPixel){\r\n    return normalPixel.xyz *2.0 -1.0;\r\n}\r\n//----------------------------------\r\n\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nin lowp float factor;\r\n#endif\r\n\r\nout vec4 color;\r\nvoid main()\r\n{\r\n    lowp vec4 basecolor = texture(_MainTex, uv_TEXCOORD0);\r\n    lowp vec4 tex = basecolor;\r\n    // if(basecolor.a < _AlphaCut)\r\n    //     discard;\r\n    // lowp vec4 fristColor=basecolor*_MainColor;\r\n    lowp vec4 fristColor = basecolor;\r\n    lowp vec4 emission = fristColor;\r\n\r\n    //材质 mask 纹理\r\n    lowp vec4 masktex = texture(_MaskTex , uv_TEXCOORD0);\r\n    //获得 normal 从 切线空间\r\n    lowp vec3 worldNorm = UnpackNormal(texture(_BumpMap, uv_TEXCOORD0));\r\n    //worldNorm 到 world 空间\r\n    worldNorm = normalize(TBNmat * worldNorm);\r\n    // emission = vec4(worldNorm , 1.0);\r\n    // emission = vec4(uv_TEXCOORD0,0,1.0);\r\n    // emission = vec4(t,1.0);\r\n\r\n\r\n    // mediump vec3 worldNorm;\r\n    // worldNorm.x = dot(tSpace0.xyz, normals);\r\n    // worldNorm.y = dot(tSpace1.xyz, normals);\r\n    // worldNorm.z = dot(tSpace2.xyz, normals);\r\n    // emission = vec4(worldNorm,1);\r\n\r\n    //normals 到 view 空间\r\n    worldNorm = (mat3(glstate_matrix_view) * worldNorm);\r\n    // emission = vec4(worldNorm,1);\r\n\r\n    mediump vec2 capCoord = worldNorm.xy;\r\n    lowp vec4 matcap1 = texture(_MatCap, capCoord * 0.5 + 0.5) * _MatCapColor * _Strength;//* tex * _Strength;\r\n    lowp vec4 matcap2 = texture(_MatCap2, capCoord * 0.5 + 0.5) * _MatCap2Color * _Strength2;\r\n    \r\n    lowp vec4 mc = (matcap1 * masktex.r + matcap2 * (1.0 - masktex.r)) * tex;\r\n\r\n    #ifdef FLUXAY_COLOR_SWITCH\r\n        //SetDunamicTime();\r\n\r\n        mediump vec4 fluax1 = vec4(.0,.0,.0,.0);\r\n        highp vec2 moveadd = (uv_TEXCOORD0 + glstate_timer * 2.0 * vec2(1.0,1.0));\r\n        mediump vec4 fluaytex = texture(_FluxayTex , uv_FluxayTex_TEXCOORD2);\r\n        mediump vec3 emissive = (fluaytex.rgb * _FluxayColor.rgb * 2.0 * (fluaytex.a * (1.0 - masktex.b) * _FluxayColor.a));\r\n        fluax1 = vec4(emissive,.0) * fluaytex.a * _FluxayColor.a;\r\n\r\n        mediump vec4 fluay2tex = texture(_FluxayTex2 , uv_FluxayTex2_TEXCOORD3);\r\n        mediump vec3 emissive2 = (fluay2tex.rgb * _FluxayColor2.rgb * 2.0 * (fluay2tex.a * (1.0 - masktex.g) * _FluxayColor2.a));\r\n        fluax1 += (vec4(emissive2,.0) * fluay2tex.a * _FluxayColor2.a);\r\n        fluax1.rgb = fluax1.rgb * mc.rgb;\r\n        mc = mc + fluax1;\r\n    #endif\r\n\r\n    emission = mc; \r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    color = emission;\r\n}","bodyfluxzy2.shader.json":"{\n    \"layer\": \"geometry\",\n\n    \"properties\": [\n        \"_MatCapColor('Main Color', Color) = (1.0, 1.0, 1.0, 1.0)\",\n        \"_MatCap2Color('Main Color 2', Color) = (1.0, 1.0, 1.0, 1.0)\",\n        \"_Strength('Strength_1', Range(0.0, 10.0)) = 3.0\",\n        \"_Strength2('Strength_2', Range(0.0, 10.0)) = 3.0\",\n\n        \"_MainTex ('Base (RGB)', Texture) = 'white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_BumpMap ('Normal Map', Texture) = 'white'{}\",\t\t\t\n        \"_MaskTex ('Mask (RGB)', Texture) = 'white'{}\",\n        \"_MatCap ('MatCap (RGB)', Texture) = 'white'{}\",\n        \"_MatCap2 ('MatCap2 (RGB)', Texture) = 'white'{}\",\n\n        \"_FluxayTex ('FluxayTex(流光纹理g)', Texture) = 'white'{}\",\n        \"_FluxayTex_ST('FluxayTex_ST',Vector) = (1,1,0,0)\",\n        \"_FluxayColor ('FluxayColor(流光颜色g)', Color) = (1,0,0,1)\",\n        \"_FluxayTex2('FluxayTex2(流光纹理b)', Texture) = 'white'{}\",\n        \"_FluxayTex2_ST('FluxayTex2_ST',Vector) = (1,1,0,0)\",\n        \"_FluxayColor2 ('FluxayColor2(流光颜色b)', Color) = (0.5,0.5,0.5,1)\"\n\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"bodyfluxzy2\",\n                \"fs\": \"bodyfluxzy2\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"bodyfluxzy2\",\n                \"fs\": \"bodyfluxzy2\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"bodyfluxzy2\",\n                \"fs\": \"bodyfluxzy2\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"bodyfluxzy2\",\n                \"fs\": \"bodyfluxzy2\"\n            }\n        ]\n    }\n}","bodyfluxzy2.vs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec4 _glesVertex;\r\nlayout(location = 4) in mediump vec4 _glesMultiTexCoord0;\r\n// layout(location = 5) in mediump vec4 _glesMultiTexCoord1;\r\nlayout(location = 2) in highp vec3 _glesTangent;\t//w 被乘到了分量里 x = x*w , y = y*w , z = z*w , 且 w 被做了 +2 的偏移映射。\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nuniform mediump vec4 _FluxayTex_ST;\r\nuniform mediump vec4 _FluxayTex2_ST;\r\n//light\r\nlowp mat4 blendMat ;\r\nlayout(location = 1) in highp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_it_modelview;\r\nuniform highp mat4 glstate_matrix_modelview;\r\n\r\n\r\n//out--------------------------\r\nout mediump vec2 uv_TEXCOORD0;\r\nout mediump vec2 uv_FluxayTex_TEXCOORD2;\r\nout mediump vec2 uv_FluxayTex2_TEXCOORD3;\r\n\r\nout highp mat3 TBNmat;\r\n\r\n// out highp vec3 tSpace0;\r\n// out highp vec3 tSpace1;\r\n// out highp vec3 tSpace2;\r\n\r\nout highp vec3 t;\r\n\r\n//获取 tangent 的 W 值\r\nlowp float tangentW(lowp vec3 _tangent){\r\n\treturn sqrt(_tangent.x * _tangent.x + _tangent.y * _tangent.y + _tangent.z * _tangent.z) - 2.0;\r\n}\r\n\r\n//---------------------------------\r\n\r\n//计算 TBN 矩阵-----------------\r\nmediump mat3 calTBNMatrix(highp mat4 _m_mat,lowp vec3 _normal,lowp vec3 _tangent)\r\n{\r\n    lowp vec3 normal = normalize(mat3(_m_mat) * normalize(_normal) );\r\n    lowp vec3 tangent = normalize(mat3(_m_mat) * normalize(_tangent));\r\n    lowp vec3 binormal = cross( normal , tangent) * tangentW(_tangent);\r\n  \treturn mat3(tangent,binormal,normal);\r\n}\r\n//-----------------------------\r\n\r\nmediump vec3 UnityObjectToWorldNormal(mediump mat3 _m_mat,mediump vec3 _normal){\r\n\t return normalize(_m_mat * _normal);\r\n}\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nlayout(location = 6) in lowp vec4 _glesBlendIndex4;\r\nlayout(location = 7) in lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0 * quat.x * quat.x;\r\n\tfloat yy = 2.0 * quat.y * quat.y;\r\n\tfloat zz = 2.0 * quat.z * quat.z;\r\n\tfloat ww = 2.0 * quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\thighp vec3 _n = vec3(.0,.0,.0);\r\n    //求世界空间法线\r\n    #ifdef SKIN\r\n    _n = normalize(mat3(blendMat) * _glesNormal);\r\n    #else\r\n    _n = _glesNormal;\r\n    #endif\r\n    lowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\r\n\tTBNmat = calTBNMatrix(glstate_matrix_model , _n , _glesTangent);\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    uv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    uv_FluxayTex_TEXCOORD2 = _glesMultiTexCoord0.xy * _FluxayTex_ST.xy + _FluxayTex_ST.zw;\r\n    uv_FluxayTex2_TEXCOORD3 = _glesMultiTexCoord0.xy * _FluxayTex2_ST.xy + _FluxayTex2_ST.zw;\r\n\r\n    //----------------------------------------------------------\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n\r\n\t// t = normalize(_glesTangent);\r\n\t\r\n\r\n\t//mediump mat3 rotation = calTANGENT_SPACE_ROTATION(_glesNormal , _glesTangent);\r\n\t\r\n\r\n\t// highp mat4 itMat = glstate_matrix_it_modelview;\r\n\r\n\t// c0 = rotation * normalize(glstate_matrix_modelview[0].xyz);\r\n\t// c1 = rotation * normalize(glstate_matrix_modelview[1].xyz);\r\n\t// c0 = TBNmat * normalize(glstate_matrix_it_modelview[0].xyz);\r\n\t// c1 = TBNmat * normalize(glstate_matrix_it_modelview[1].xyz);\r\n\r\n\t\r\n\t// highp mat3 wMat = mat3(glstate_matrix_model);\r\n\t// highp vec3 worldNormal = UnityObjectToWorldNormal(wMat , _glesNormal);\r\n\t// highp vec3 worldTangent = wMat * _glesTangent;\r\n\t// highp vec3 worldBinormal = cross(worldNormal, worldTangent) ;\r\n\t// tSpace0 = vec3(worldTangent.x, worldBinormal.x, worldNormal.x);\r\n\t// tSpace1 = vec3(worldTangent.y, worldBinormal.y, worldNormal.y);\r\n\t// tSpace2 = vec3(worldTangent.z, worldBinormal.z, worldNormal.z);\r\n\r\n\r\n    \r\n\tposition = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse.fs.glsl":"#version 300 es\n\nprecision lowp float;\nuniform lowp sampler2D _MainTex;\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\nin mediump vec2 xlv_TEXCOORD0;\n\n//light\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \nbool hasLight = false;\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\nuniform lowp float glstate_lightcount;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\nuniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nin lowp vec3 v_N;\nin lowp vec3 v_Mpos;\n\n//texture2DEtC1Mark\n\n#ifdef LIGHTMAP\nuniform lowp float glstate_lightmapRGBAF16;\nuniform lowp sampler2D _LightmapTex;\nin mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nin lowp float factor;\n#endif\n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\n{\n    lowp vec3 v3 = lightPos.xyz - worldpos;\n    lowp float len = length(v3);\n    len = len > range ? range : len;\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(v3); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n}\n\nvoid calcCOLOR(){\n    int c =int(glstate_lightcount);\n\tif(c>0){\n        hasLight = true;\n        lowp float diff=0.0;\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tif(i>=c)break;\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\n\t\t}\n\t\txlv_COLOR.w = 1.0;  \n    }\n}\n\nout vec4 color; \nvoid main() \n{\n    lowp vec4 basecolor = texture(_MainTex, xlv_TEXCOORD0);\n    if(basecolor.a < _AlphaCut)\n        discard;\n    lowp vec4 fristColor=basecolor*_MainColor;\n    lowp vec4 emission = fristColor;\n\n    //----------------------------------------------------------\n    //light\n    calcCOLOR();\n    \n#ifdef LIGHTMAP\n    lowp vec4 lightmap = texture(_LightmapTex, lightmap_TEXCOORD);\n    if(glstate_lightmapRGBAF16 == 1.0){\n        emission.xyz *= lightmap.xyz;\n    }else{\n        emission.xyz *= decode_hdr(lightmap);\n    }\n    if(hasLight){ // have light\n        fristColor = fristColor * xlv_COLOR ;\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\n    }\n#else\n\tif(hasLight){ // have light\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\n    }\n#endif\n\n#ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n#endif\n    \n    color = emission;\n}","diffuse.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"instance\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"instance_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ]\n    }\n}","diffuse.vs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec3    _glesVertex;\r\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nout mediump vec2 xlv_TEXCOORD0;\r\n//light\r\nlowp mat4 blendMat ;\r\nlayout(location = 1) in highp vec3    _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform lowp float glstate_lightcount;\r\n\r\nout highp vec3 v_N;\r\nout highp vec3 v_Mpos;\r\n\r\n#ifdef INSTANCE\r\n//instance_matrix 固定地址\r\nlayout(location = 12) in highp mat4 instance_matrix;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nlayout(location = 5) in mediump vec2 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\nuniform lowp float glstate_lightmapUV;\r\nout mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nlayout(location = 6) in lowp vec4    _glesBlendIndex4;\r\nlayout(location = 7) in mediump vec4    _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\tint c =int(glstate_lightcount);\r\n\tif(c>0){\r\n\t\t//求世界空间法线\r\n\t\t#ifdef SKIN\r\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\r\n\t\t#else\r\n\t\tv_N = _glesNormal;\r\n\t\t#endif\r\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\t\tv_N =normalize(normalmat*v_N);\r\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\r\n\t}\r\n}\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = (1.0 - glstate_lightmapUV) * _glesMultiTexCoord0  + glstate_lightmapUV * _glesMultiTexCoord1;\t//unity lightMap UV ,优先使用UV1,次之UV0 \r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n\r\n\t#ifdef INSTANCE\r\n        position = instance_matrix * position;\r\n    #endif\r\n\t\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse_bothside.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ]\n    }\n}","f14trans.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D _Main_Tex;\n\nin lowp vec4 xlv_COLOR;\nin mediump vec2 xlv_TEXCOORD0;       \n//texture2DEtC1Mark\n   \nout vec4 color; \nvoid main() \n{\n    lowp vec4 basecolor = texture(_Main_Tex, xlv_TEXCOORD0);\n    color =basecolor*xlv_COLOR;\n    //color =vec4(1,0,0,1);\n}","f14trans.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec3    _glesVertex;\nlayout(location = 4) in mediump vec4    _glesMultiTexCoord0;   \nlayout(location = 3) in highp vec4    _glesColor;\n\nuniform lowp vec4 _Main_Color;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Main_Tex_ST;\n\n\nout lowp vec4 xlv_COLOR;\nout mediump vec2 xlv_TEXCOORD0;                \nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\n    xlv_COLOR = _Main_Color*_glesColor;\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n                \n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \n}","grey_mask_ui.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex;\nuniform highp vec4 _maskRect;\n\nin lowp float xlv_Alpha;\nin highp vec2 xlv_TEXCOORD0;\nin highp vec2 mask_TEXCOORD;\n\nbool CalcuCut(){    \n    highp float l; \n    highp float t; \n    highp float r; \n    highp float b; \n    highp vec2 texc1; \n    bool beCut; \n    l = _maskRect.x; \n    t = _maskRect.y; \n    r = _maskRect.z + l; \n    b = _maskRect.w + t; \n    texc1 = mask_TEXCOORD; \n    if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){  \n        beCut = true;  \n    }else{ \n        beCut = false; \n    } \n    return beCut; \n} \n\nout vec4 color;\nvoid main()\n{\n    if(CalcuCut()) discard;\n    lowp vec4 final = texture(_MainTex, xlv_TEXCOORD0);\n    lowp float lum = (final.x + final.y + final.z) *  0.3333; \n    final = vec4(lum,lum,lum,xlv_Alpha * final.a);\n\n    color = final ;\n}","grey_mask_ui.shader.json":"{\n    \"layer\": \"transparent\",\n    \"queue\": 100,\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_maskRect('MaskRect',Vector) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"ztest\":\"false\",\n\t\t\t\t\"zwrite\":\"false\",\n                \"vs\": \"grey_mask_ui\",\n                \"fs\": \"grey_mask_ui\"\n            }\n        ]\n    }\n}","grey_mask_ui.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in vec4 _glesVertex;\nlayout(location = 3) in vec4 _glesColor;\nlayout(location = 4) in vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp; \n\nout lowp float xlv_Alpha;\nout highp vec2 xlv_TEXCOORD0;\nout highp vec2 mask_TEXCOORD;\n\nvoid main(){\n    highp vec4 position = vec4(_glesVertex.xyz,1.0);    \n    xlv_Alpha = _glesColor.a;\n    xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);  \n    mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0; \n    mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0; \n    position = (glstate_matrix_mvp * position);\n    gl_Position = position;\n}","grey_ui.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex;\n\nin lowp float xlv_Alpha;\nin highp vec2 xlv_TEXCOORD0;\n\nout vec4 color;\nvoid main()\n{\n    lowp vec4 final = texture(_MainTex, xlv_TEXCOORD0);\n    lowp float lum = (final.x + final.y + final.z) *  0.3333; \n    final = vec4(lum,lum,lum,xlv_Alpha * final.a);\n\n    color = final ;\n}","grey_ui.shader.json":"{\n    \"layer\": \"transparent\",\n    \"queue\": 100,\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"ztest\":\"false\",\n\t\t\t\t\"zwrite\":\"false\",\n                \"vs\": \"grey_ui\",\n                \"fs\": \"grey_ui\"\n            }\n        ]\n    }\n}","grey_ui.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in vec4 _glesVertex;\nlayout(location = 4) in vec4 _glesMultiTexCoord0;\nlayout(location = 3) in vec4 _glesColor;\n\nuniform highp mat4 glstate_matrix_mvp; \n\nout lowp float xlv_Alpha;\nout highp vec2 xlv_TEXCOORD0;\n\nvoid main(){\n    highp vec4 position = vec4(_glesVertex.xyz,1.0);    \n    position = (glstate_matrix_mvp * position);\n    xlv_Alpha = _glesColor.a;\n    xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);  \n    gl_Position = position;\n}","mask_add_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_add_tint_uvroll.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\",\n        \"_speedu('speedu',Float) = -1\",\n        \"_speedv('speedv',Float) = 0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_blend_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_blend_tint_uvroll.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\",\n        \"_speedu('speedu',Float) = -1\",\n        \"_speedv('speedv',Float) = 0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_trans_tint.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex; \nuniform sampler2D _Mask; \nuniform mediump vec4 _Main_Color;\n\nin mediump vec2 _maintex_uv;\nin mediump vec2 _mask_uv;\n\nuniform lowp float _mixColorRate;\nuniform lowp float _mixAlphaRate;\n\n//texture2DEtC1Mark\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nin mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nin lowp float factor;\n#endif\nout vec4 color; \nvoid main()    \n{\n    highp vec4 basecolor=texture(_MainTex,_maintex_uv);\n    highp vec4 maskcolor=texture(_Mask,_mask_uv);\n\n    lowp vec3 tempcolor=_Main_Color.rgb*basecolor.rgb*maskcolor.rgb*_mixColorRate;\n    lowp float tempAlpha=_Main_Color.a*basecolor.a*maskcolor.a*_mixAlphaRate;\n    lowp vec4 emission=vec4(tempcolor,tempAlpha);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    #ifdef FOG\n    emission= mix(vec4(0,0,0,0), emission, factor);\n\n    //emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    color = emission;\n\n\n}\n","mask_trans_tint.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec3    _glesVertex;\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _MainTex_ST;\nuniform mediump vec4 _Mask_ST;\nout mediump vec2 _maintex_uv;\nout mediump vec2 _mask_uv;\n\n#ifdef LIGHTMAP\nlayout(location = 5) in mediump vec4    _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nout mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\n#ifdef SKIN\nlayout(location = 6) in lowp vec4    _glesBlendIndex4;\nlayout(location = 7) in mediump vec4    _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    _maintex_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position=calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position =glstate_matrix_mvp * position;\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\tgl_Position = position;\n}","mul_color_flow_font.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex;\nuniform highp vec4 _maskRect;\nuniform float glstate_timer;\nuniform highp float _outlineWidth; // 描边宽度\n\n\nin highp float xlv_X;\nin lowp float xlv_Alpha;\nin lowp vec4 xlv_COLOR;                 \nin lowp vec4 xlv_COLOREx;\nin highp vec2 xlv_TEXCOORD0;\n\n#define lerp(a, b, v)   (a) * (1.0 - (v)) + (b) * (v) \n\nout vec4 color;\nvoid main()\n{\n    vec4 texColor = texture(_MainTex, xlv_TEXCOORD0);\n\n    // 在gd3d中使用的sdf字体做了最大值为2像素的有向距离运算且保存到位图上。\n    // 颜色值[0,255]对于区间[-2,2]。\n    // 颜色值v表示距离字符边缘有 (v/255*4-2) 单位距离。单位距离为正表示在字符内，否则在字符外。\n    \n    float _DistanceMark = 0.0; // 距离为 0 处是字符边缘\n    float _SmoothDelta = 0.5; // 在字符边缘 0.5 像素进行插值 \n\n    float _OutlineDistanceMark = -_outlineWidth; // 描边位置\n\n    vec4 col = texColor;\n    float distance = col.r * 4.0 - 2.0;\n\n    // 平滑字体边缘\n    col.a = smoothstep(_DistanceMark - _SmoothDelta, _DistanceMark + _SmoothDelta, distance);\n    \n    // //填充色\n    // col.rgb = xlv_COLOR.rgb;\n\n    //填充色 渐变色\n    mediump float changeVal = sin(glstate_timer * 0.5 - xlv_X * 4.0) * 2.0;\n    changeVal *= changeVal;\n    mediump vec3 col1 = lerp(vec3(0.44, 1.0, 0.54),vec3(0.97,0.54,1.0),clamp(changeVal,0.0,1.0));\n    col1 = lerp(col1, vec3(1.0, 1.0, 0.44), clamp(changeVal - 1.5,0.0,1.0));\n    col1 = lerp(col1, vec3(0.44, 1.0, 0.54), clamp(changeVal - 3.0,0.0,1.0));\n    col.rgb = col1;\n\n    // Outlining 描边\n    vec4 outlineCol = vec4(1.0,1.0,1.0,1.0);\n    outlineCol.a = smoothstep(_OutlineDistanceMark - _outlineWidth, _OutlineDistanceMark + _outlineWidth, distance);\n    outlineCol.rgb = xlv_COLOREx.rgb;\n    outlineCol.a = outlineCol.a * xlv_COLOREx.a;\n\n    // 混合字体与描边颜色\n    col = mix(outlineCol, col, col.a);\n    col.a = col.a * xlv_COLOR.a;\n\n\n    color = col ;\n}","mul_color_flow_font.shader.json":"{\n    \"layer\": \"transparent\",\n    \"queue\": 100,\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"ztest\":\"false\",\n\t\t\t\t\"zwrite\":\"false\",\n                \"vs\": \"mul_color_flow_font\",\n                \"fs\": \"mul_color_flow_font\"\n            }\n        ]\n    }\n}","mul_color_flow_font.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in vec4 _glesVertex;\nlayout(location = 3) in vec4 _glesColor;\nlayout(location = 8) in vec4 _glesColorEx;\nlayout(location = 4) in vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp; \n\nout highp float xlv_X;\nout lowp float xlv_Alpha;\nout lowp vec4 xlv_COLOR;                 \nout lowp vec4 xlv_COLOREx;\nout highp vec2 xlv_TEXCOORD0;\n\nvoid main(){\n    highp vec4 position = vec4(_glesVertex.xyz,1.0);    \n    position = (glstate_matrix_mvp * position);\n    xlv_X = position.x;\n    xlv_Alpha = _glesColor.a;\n    xlv_COLOR = _glesColor;                      \n    xlv_COLOREx = _glesColorEx;   \n    xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);  \n    gl_Position = position;\n}","particlesystem.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nin vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\n\nin vec4 v_color;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nin lowp float factor;\n#endif\n\nout vec4 color;\nvoid main()\n{\n    vec4 _color = 2.0 * v_color * _TintColor * texture(_MainTex, v_uv);\n\n    #ifdef FOG\n        _color.xyz = mix(glstate_fog_color.rgb, _color.rgb, factor);\n    #endif\n    \n    color = color;\n}","particlesystem.vs.glsl":"#version 300 es\n\nprecision mediump float;  \n\n//坐标属性\nlayout(location = 0) in vec3 _glesVertex;\nlayout(location = 4) in vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nuniform vec4 _MainTex_ST;\n\nuniform float _UVSpeedX;\nuniform float _UVSpeedY;\nuniform float glstate_timer;\n\nout vec4 v_color;\nout vec2 v_uv;\n\n#ifdef INSTANCE\n    in vec4 a_particle_position;\n    in vec4 a_particle_scale;\n    in vec4 a_particle_rotation;\n    in vec4 a_particle_color;\n    in vec4 a_particle_tilingOffset;\n    in vec4 a_particle_flipUV;\n#else\n    uniform vec4 a_particle_position;\n    uniform vec4 a_particle_scale;\n    uniform vec4 a_particle_rotation;\n    uniform vec4 a_particle_color;\n    uniform vec4 a_particle_tilingOffset;\n    uniform vec4 a_particle_flipUV;\n#endif\n\nuniform mat4 u_particle_billboardMatrix;\nuniform vec4 u_particle_pivotOffset;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\nmat3 makeParticleRotationMatrix(vec3 rotation)\n{\n    float DEG2RAD = 3.1415926 / 180.0;\n    \n    float rx = rotation.x * DEG2RAD;\n    float ry = rotation.y * DEG2RAD;\n    float rz = rotation.z * DEG2RAD;\n\n    float sinX = sin(rx);\n    float cosX = cos(rx);\n    float sinY = sin(ry);\n    float cosY = cos(ry);\n    float sinZ = sin(rz);\n    float cosZ = cos(rz);\n\n    mat3 tmp;\n    float ce = cosY * cosZ;\n    float cf = cosY * sinZ;\n    float de = sinY * cosZ;\n    float df = sinY * sinZ;\n\n    float te0 = ce + df * sinX;\n    float te4 = de * sinX - cf;\n    float te8 = cosX * sinY;\n\n    float te1 = cosX * sinZ;\n    float te5 = cosX * cosZ;\n    float te9 = - sinX;\n\n    float te2 = cf * sinX - de;\n    float te6 = df + ce * sinX;\n    float te10 = cosX * cosY;\n\n    tmp[0] = vec3(te0, te1, te2);\n    tmp[1] = vec3(te4, te5, te6);\n    tmp[2] = vec3(te8, te9, te10);\n            \n    return tmp;\n}\n\nvec4 particleAnimation(vec4 position) \n{\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\n    \n    position.xyz = position.xyz + u_particle_pivotOffset.xyz;\n    \n    // 计算缩放\n    position.xyz = position.xyz * a_particle_scale.xyz;\n\n    // 计算旋转\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\n    position.xyz = rMat * position.xyz;\n    position.xyz = billboardMatrix * position.xyz;\n\n    // 位移\n    position.xyz = position.xyz + a_particle_position.xyz;\n\n    // 颜色\n    v_color = a_particle_color;\n\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\n    \n    return position;\n}\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    position = particleAnimation(position);\n\n    v_uv = v_uv + vec2(_UVSpeedX,_UVSpeedY) * glstate_timer;\n\n    //计算投影坐标\n    position = glstate_matrix_mvp * position;\n\n    #ifdef FOG\n        factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n        factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    gl_Position = position;\n}","particlesystem_additive.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_additive_transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","particlesystem_alphablended.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_alphablended_transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","particlesystem_transparent_particles_standard.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex;\n\nuniform vec4 u_color;\n\nuniform float EXTENDED_PARTICLES;\nuniform float _EmissionSaturation;\nuniform float _OpacitySaturation;\nuniform float _ColorMultiplier;\n\nuniform float COLOR_RAMP;\nuniform sampler2D _ColorRamp;\nuniform vec4 _ColorRamp_ST;\nuniform float COLOR_TINT;\nuniform vec4 _BasicColor;\nuniform vec4 _SaturatedColor;\n\nuniform float DISSOLVE_ENABLED;\nuniform vec4 _DissolveStep;\n\nuniform float NOISE_TEXTURE;\nuniform sampler2D _NoiseTex;\nuniform vec4 _TintColor;\n\nuniform float EMISSIVEPOWER;\nuniform float _EmissivePower;\n\nuniform float _ABOffset;\n\nuniform float _GlobalAlpha;\n\nin vec2 v_uv;\nin vec4 v_color;\n\nin vec2 v_particledata;\nin vec2 v_noiseuv;\n\nuniform float APPLY_RGB_COLOR_VERTEX;\nuniform float NOISE_TEXTURE_EMISSION;\nuniform float NOISE_TEXTURE_ALPHA;\nuniform float NOISE_TEXTURE_DISSOLVE;\n\nuniform float BlendMode;\n\nout vec4 color;\nvoid main() \n{\n    vec4 tex = texture(_MainTex, v_uv);\n\n    vec4 col = vec4(1.0, 1.0, 1.0, 1.0);\n\n    vec4 vcolor = vec4(1.0, 1.0, 1.0, v_color.w);\n\n    if( EXTENDED_PARTICLES > 0.5 )\n    {\n        if( APPLY_RGB_COLOR_VERTEX > 0.5)\n        {\n            vcolor = v_color;\n        }\n\n        float nEmission = 1.0;\n        float nAlpha = 1.0;\n        float nDissolve = 1.0;\n        \n        if( NOISE_TEXTURE > 0.5)\n        {\n            vec3 noise = texture(_NoiseTex, v_noiseuv).xyz;\n        \n            if( NOISE_TEXTURE_EMISSION > 0.5)\n            {\n                nEmission = noise.x;\n            }\n            else\n            {\n                nEmission = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_ALPHA > 0.5)\n            {\n                nAlpha = noise.y;\n            }\n            else\n            {\n                nAlpha = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_DISSOLVE > 0.5)\n            {\n                nDissolve = noise.z;\n            }\n            else\n            {\n                nDissolve = 1.0;\n            }\n        }\n    \n        if( DISSOLVE_ENABLED > 0.5)\n        {\n            float ramp = -1.0 + (v_particledata.x * 2.0);\n            col.a = clamp(tex.g * smoothstep(_DissolveStep.x, _DissolveStep.y, (tex.b + ramp) * nDissolve) * _OpacitySaturation * vcolor.w * nAlpha, 0.0, 1.0);\n        }\n        else\n        {\n            col.a = clamp(tex.g * _OpacitySaturation * vcolor.w, 0.0, 1.0) * nAlpha;\n        }\n    \n        float lerpValue = 0.0;\n        if(COLOR_TINT < 0.5)\n        {\n            lerpValue = clamp(tex.r * v_particledata.y * _ColorMultiplier * nEmission, 0.0, 1.0);\n        }\n    \n        if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5)\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * _EmissionSaturation;\n                }\n            }\n            col.a *= _GlobalAlpha;\n        }\n        else\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * col.a * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5 )\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation * col.a;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * col.a * _EmissionSaturation;\n                }\n            }\n            col *= _GlobalAlpha;\n        }\n    }\n    else\n    {\n        if( 3.5 < BlendMode && BlendMode < 4.5 ) //4\n        {\n            tex *= _TintColor;\n            float luminance = clamp(dot(tex, vec4(0.2126, 0.7152, 0.0722, 0.0)) * tex.a * _ABOffset, 0.0, 1.0);\n            vec4 one = vec4(1, 1, 1, 1);\n            col = mix(2.0 * (v_color * tex), one - 2.0 * (one - v_color) * (one - tex), luminance);\n        }\n        else\n        {\n            col = v_color * tex;\n            col *= _TintColor;\n        \n            if( EMISSIVEPOWER > 0.5)\n            {\n                col *= _EmissivePower;\n            }\n            \n            if( 0.5 < BlendMode && BlendMode < 1.5 ) //1\n            {\n                col.rgb *= col.a;\n            }\n            else\n            {\n                if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n                {\n                    col *= 2.0;\n                }\n                else\n                {\n                    if( 1.5 < BlendMode && BlendMode < 2.5 ) //2\n                    {\n                        col *= 4.0;\n                    }\n                }\n            }\n        }\n    \n        col *= _GlobalAlpha;\n\n    }\n\n    color = col;\n}","particlesystem_transparent_particles_standard.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in vec3 _glesVertex;\nlayout(location = 4) in vec2 _glesMultiTexCoord0;\nlayout(location = 3) in vec4 _glesColor;\n\nuniform vec4 _MainTex_ST;\n\nuniform vec4 _Panning;\nuniform float glstate_timer;\n\nuniform vec4 _NoiseTex_ST;\nuniform vec4 _NoisePanning;\n\nuniform mat4 glstate_matrix_mvp;\n\nout vec2 v_uv;\nout vec4 v_color;\n\nuniform float EXTENDED_PARTICLES;\nout vec2 v_particledata;\n\nuniform float NOISE_TEXTURE;\nuniform float NOISEUV;\nout vec2 v_noiseuv;\n\n\n\nin vec3 a_particle_position;\nin vec3 a_particle_scale;\nin vec3 a_particle_rotation;\nin vec4 a_particle_color;\nin vec4 a_particle_tilingOffset;\nin vec2 a_particle_flipUV;\n\nuniform mat4 u_particle_billboardMatrix;\n\n\nmat3 makeParticleRotationMatrix(vec3 rotation)\n{\n    float DEG2RAD = 3.1415926 / 180.0;\n    \n    float rx = rotation.x * DEG2RAD;\n    float ry = rotation.y * DEG2RAD;\n    float rz = rotation.z * DEG2RAD;\n\n    float sinX = sin(rx);\n    float cosX = cos(rx);\n    float sinY = sin(ry);\n    float cosY = cos(ry);\n    float sinZ = sin(rz);\n    float cosZ = cos(rz);\n\n    mat3 tmp;\n    float ce = cosY * cosZ;\n    float cf = cosY * sinZ;\n    float de = sinY * cosZ;\n    float df = sinY * sinZ;\n\n    float te0 = ce + df * sinX;\n    float te4 = de * sinX - cf;\n    float te8 = cosX * sinY;\n\n    float te1 = cosX * sinZ;\n    float te5 = cosX * cosZ;\n    float te9 = - sinX;\n\n    float te2 = cf * sinX - de;\n    float te6 = df + ce * sinX;\n    float te10 = cosX * cosY;\n\n    tmp[0] = vec3(te0, te1, te2);\n    tmp[1] = vec3(te4, te5, te6);\n    tmp[2] = vec3(te8, te9, te10);\n            \n    return tmp;\n}\n\nvec4 particleAnimation(vec4 position) \n{\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\n    \n    // 计算缩放\n    position.xyz = position.xyz * a_particle_scale.xyz;\n\n    // 计算旋转\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\n    position.xyz = rMat * position.xyz;\n    position.xyz = billboardMatrix * position.xyz;\n\n    // 位移\n    position.xyz = position.xyz + a_particle_position.xyz;\n\n    // 颜色\n    v_color = a_particle_color * _glesColor;\n\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\n    \n    return position;\n}\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n\n    position = particleAnimation(position);\n    \n    gl_Position = glstate_matrix_mvp * position;\n    v_uv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_Panning.xy * glstate_timer);\n    // v_color = _glesColor;\n    // v_color = vec4(1.0,1.0,1.0,1.0);\n\n    if(EXTENDED_PARTICLES > 0.5)\n    {\n        if( NOISE_TEXTURE > 0.5)\n        {\n            if( NOISEUV > 0.5)\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _NoiseTex_ST.xy + _NoiseTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n            else\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n        }\n    }\n    else\n    {\n        // v_particledata = _glesMultiTexCoord0.zw;\n        v_particledata = _glesMultiTexCoord0;\n    }\n}","particles_add.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"add\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_add_multiply.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"addpremult\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_add_notest.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"add\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"ztest\":\"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend_multiply.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blendpremult\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend_notest.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"ztest\":\"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_diffuse.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"showface\": \"ccw\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particle_mask_add_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"par_mask_tint\",\n                \"fs\": \"par_mask_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particle_mask_blend_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"par_mask_tint\",\n                \"fs\": \"par_mask_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","par_mask_tint.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _Main_Tex; \nuniform sampler2D _Mask; \n\nin mediump vec2 _maintex_uv;\nin mediump vec2 _mask_uv;\n\nin mediump vec4 v_color;\n\n//textureEtC1Mark\nout vec4 color;\nvoid main()    \n{\n    highp vec4 basecolor=texture(_Main_Tex,_maintex_uv);\n    highp vec4 maskcolor=texture(_Mask,_mask_uv);\n\n    mediump vec3 tempcolor=v_color.rgb*basecolor.rgb*maskcolor.rgb;\n    mediump float tempAlpha=v_color.a*basecolor.a*maskcolor.a;\n    mediump vec4 emission=vec4(tempcolor,tempAlpha);\n    \n    color = emission;\n}\n","par_mask_tint.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec3 _glesVertex;\nlayout(location = 3) in highp vec4 _glesColor;\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _Main_Tex_ST;\nuniform mediump vec4 _Mask_ST;\nout mediump vec2 _maintex_uv;\nout mediump vec2 _mask_uv;\n\nuniform mediump vec4 _Main_Color;\nuniform mediump float _mixColorRate;\nuniform mediump float _mixAlphaRate;\n\nout mediump vec4 v_color;\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\tposition =glstate_matrix_mvp * position;\n\t \n    _maintex_uv = _glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\n\tv_color=_glesColor*_Main_Color;\n\tv_color.rgb=v_color.rgb*_mixColorRate;\n\tv_color.a=v_color.a*_mixAlphaRate;\n\n\tgl_Position = position;\n}","pbr.fs.glsl":"#version 300 es\n\n// #ifdef TEXTURE_LOD\n// #extension GL_EXT_shader_texture_lod : enable\n// #endif\n\n#define TEXTURE_LOD\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI          3.141592653589\n#define GAMMA 2.2\n\n// uniform vec4 light_1;\n// uniform vec4 light_2;\n\nuniform float diffuseIntensity;\nuniform float specularIntensity;\nuniform float uvRepeat;\nuniform float alphaCutoff;      //alphaCutoff\n\nuniform lowp float glstate_lightcount;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\nuniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nuniform samplerCube u_env;      // IBL\nuniform samplerCube u_diffuse;  // diffuse\nuniform float u_Exposure;\n// uniform sampler2D brdf;       // BRDF LUT\nuniform vec4 glstate_eyepos;\n\n// PBR 材质贴图\nuniform sampler2D uv_Normal;\nuniform sampler2D uv_Basecolor;\nuniform sampler2D uv_MetallicRoughness;\nuniform sampler2D uv_AO;\nuniform sampler2D uv_Emissive;\n\n// Customize value\nuniform vec4 CustomBasecolor;\nuniform float CustomMetallic;\nuniform float CustomRoughness;\nuniform vec4 CustomEmissiveColor;\n\n#define TEX_FORMAT_METALLIC     rgb\n#define TEX_FORMAT_ROUGHNESS    a\n\nin vec3 v_pos;\nin vec2 xlv_TEXCOORD0;\nin mat3 TBN;\n\n#ifdef LIGHTMAP\nuniform lowp float glstate_lightmapRGBAF16;\nuniform lowp sampler2D _LightmapTex;\nin mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nin lowp float factor;\n#endif\n\nvec4 sRGBtoLINEAR(vec4 color) {\n    return vec4(pow(color.rgb, vec3(GAMMA)), color.a);\n}\nvec4 LINEARtoSRGB(vec4 color) {\n    return vec4(pow(color.rgb, vec3(1.0 / GAMMA)), color.a);\n}\n\nvec3 toneMapACES(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return pow(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0), vec3(1.0 / GAMMA));\n}\n\nvec2 DFGApprox(float NoV, float roughness) {\n    float dotNV = clamp(NoV, 0., 1.);\n    vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n// Fresnel - F0 = Metalness\nvec3 F_Schlick(float VoH, vec3 F0) {\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - VoH, 5.0);\n}\n\n// Geometric\n// >    Schlick with k = α/2 matches Smith very closely\nfloat G_UE4(float NoV, float NoH, float VoH, float NoL, float roughness) {\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float l = NoL / (NoL * (1.0 - k) + k);  // There are another version which use NoH & LoH\n    float v = NoV / (NoV * (1.0 - k) + k);\n    return l * v;\n}\n\n// a (alphaRoughness) = Roughness\n// Distribution AKA normal distribution function (NDF)\n// Trowbridge-Reitz\nfloat D_GGX(float a, float NoH) {\n    a = a * a;\n    // float f = (NoH * a - NoH) * NoH + 1.0;  // NoH * NoH * (a - 1.0) + 1.0;\n    float f = NoH * NoH * (a - 1.0) + 1.0;\n    return a / (PI * f * f);\n}\n\n// mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv){\n//     // get edge vectors of the pixel triangle\n//     vec3 dp1 = dFdx( p );\n//     vec3 dp2 = dFdy( p );\n//     vec2 duv1 = dFdx( uv );\n//     vec2 duv2 = dFdy( uv );\n\n//     // solve the linear system\n//     vec3 dp2perp = cross( dp2, N );\n//     vec3 dp1perp = cross( N, dp1 );\n//     vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n//     vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n//     // construct a scale-invariant frame\n//     float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n//     return mat3( T * invmax, B * invmax, N );\n// }\n\n// decode RGBE data after LOD due to RGB32F mipmap issue\n vec3 decoRGBE(vec4 r) {\n    if(r.a != 0. && r.a <= 0.7372549019607844) {    //判读 0.7372 避免 expVal > 60 后出现问题。 \n        float expVal = r.a * 255. - 128.;\n        float e = exp2(expVal);\n        return vec3(r.r * e, r.g * e, r.b * e);\n    }\n    return  vec3(0.0);\n}\n\nstruct st_core {\n    vec4 diffuse;\n    vec3 f0;\n    vec3 N;\n    vec3 V;\n    vec3 R;\n    float NoV;\n    float metallic;\n    float roughness;\n    float alphaRoughness;\n};\n\nstruct lightData{\n    vec3 L;\n    float rVal;\n};\n\nst_core init() {\n    st_core temp;\n\n    // PBR Material\n    temp.diffuse = (sRGBtoLINEAR(texture(uv_Basecolor, xlv_TEXCOORD0 * uvRepeat)) * CustomBasecolor);\n\n    vec3 rm = texture(uv_MetallicRoughness, xlv_TEXCOORD0 * uvRepeat).rgb;\n    temp.roughness = clamp(rm.g, 0.04, 1.0) * CustomRoughness;\n    temp.alphaRoughness = temp.roughness * temp.roughness;\n    temp.metallic = clamp(rm.b, 0.0, 1.0) * CustomMetallic;\n\n    // vec4 AO = sRGBtoLINEAR(texture(uv_AO, xlv_TEXCOORD0 * uvRepeat));\n\n    vec3 f0 = vec3(0.04);\n    temp.f0 = mix(f0, temp.diffuse.xyz, temp.metallic);\n\n    temp.diffuse.rgb = temp.diffuse.rgb * (vec3(1.) - f0) * (1. - temp.metallic);\n    // temp.diffuse/=PI;\n\n    temp.V = normalize(glstate_eyepos.xyz - v_pos);\n    // mat3 TBN = cotangent_frame(temp.N, temp.V, xlv_TEXCOORD0 * uvRepeat);\n    vec3 normalAddation = texture(uv_Normal, xlv_TEXCOORD0 * uvRepeat).rgb * 2. - 1.;\n    temp.N = normalize(TBN * normalAddation);\n\n    temp.NoV = clamp(abs(dot(temp.N, temp.V)), 0.001, 1.0);\n    temp.R = -normalize(reflect(temp.V, temp.N));\n\n    return temp;\n}\n\nvec3 lightBRDF(lightData ld, st_core core) {\n    vec3 L = normalize(ld.L);\n    vec3 H = normalize(core.V + L);\n\n    float NoL = clamp(dot(core.N, L), 0.001, 1.0);\n    float NoH = clamp(dot(core.N, H), 0.0, 1.0);\n    // float LoH = clamp(dot(L, H), 0.0, 1.0);\n    float VoH = clamp(dot(core.V, H), 0.0, 1.0);\n\n    // vec3 diffuse = core.Basecolor.rgb * NoL / PI;\n\n    vec3 F = F_Schlick(VoH, core.f0);\n    float G = G_UE4(core.NoV, NoH, VoH, NoL, core.roughness);\n    float D = D_GGX(core.alphaRoughness, NoH);\n    \n    //直接光照(镜面反射)\n    vec3 specContrib = F * G * D / (4.0 * NoL * core.NoV);\n    //间接光照(漫反射)\n    vec3 diffuseContrib = (1.0 - F) * core.diffuse.rgb / PI;\n\n    // vec3 color = NoL * (diffuseContrib + specContrib);\n    vec3 color = ld.rVal * (diffuseContrib + specContrib);\n\n    return color;\n}\n\n//calcLight 计算灯光数据函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlightData calcLight(vec3 N,vec3 worldpos,vec4 lightPos,vec4 lightDir,float cosspot,float range)\n{\n    lightData ld;\n\n    vec3 v3 = lightPos.xyz - worldpos;\n    float len = length(v3);\n    len = len > range ? range : len;\n    //求入射角，点光源&聚光灯\n    vec3 L = normalize(v3); \n    //求张角 聚光灯 也是方向光入射角\n    vec3 L2 = -lightDir.xyz;\n    float dotSpot = dot(L,L2);\n    float spotVal = smoothstep(cosspot , 1.0 , dotSpot);\n    float atten = pow(1.0 - len/range , 3.0);\n\n    //光方向\n    ld.L = mix(L2 , L , lightPos.w);\n    float NoL = clamp(dot(N , ld.L) , 0.0 , 1.0);\n\n    //反射度\n    float r = NoL * atten;                       //点光 和 射灯\n    r *= mix(1.0 , spotVal , lightDir.w);        // lightDir.w = 0 点光, w = 1 射灯 (有角度约束)\n    float rDir = NoL;                            //方向光\n    ld.rVal = mix(rDir , r , lightPos.w);        //lightPos.w = 0 方向光 ，w = 1 点光 和 射灯\n\n    return ld;\n}\n\nout vec4 color; \nvoid main() {\n    //alpha Test\n    vec4 baseTex = texture(uv_Basecolor, xlv_TEXCOORD0 * uvRepeat);\n    if(baseTex.a < alphaCutoff){\n        discard;\n    }\n\n    st_core c = init();\n    float lod = clamp(c.roughness * 10.0, 0.0, 11.0);\n    vec3 directL;\n\n    //实时灯光 直接光照 照明贡献计算----------------------------\n    // vec2 envBRDF    = texture(brdf, vec2(clamp(c.NoV, 0.0, 0.9999999), clamp(1.0-c.Roughness, 0.0, 0.9999999))).rg;\n    // int lightCount = int(min(3., glstate_lightcount));\n    int lightCount = int(glstate_lightcount);\n    if (lightCount > 0) {\n        for (int i = 0; i < 8; i++) {\n            if (i >= lightCount) break;\n            lightData ld = calcLight(c.N,v_pos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n            directL += lightBRDF(ld , c) * glstate_vec4_lightcolors[i].rgb * glstate_float_lightintensity[i];\n        }\n    }\n\n    //环境 间接光照 照明贡献计算----------------------------\n    vec2 brdf = DFGApprox(c.NoV, c.roughness);\n    //镜面反射\n    #ifdef TEXTURE_LOD\n        // vec3 IBLColor = decoRGBE(textureCubeLodEXT(u_env, c.R, lod));\n        vec3 IBLColor = decoRGBE(textureLod(u_env, c.R, lod));\n    #else\n        vec3 IBLColor = decoRGBE(texture(u_env, c.R));\n    #endif\n    vec3 IBLspecular = 1.0 * IBLColor * (c.f0 * brdf.x + brdf.y);\n    vec3 indirectSpec = IBLspecular * specularIntensity;\n\n    //漫反射\n    #ifdef TEXTURE_LOD\n        // vec3 indirectDiff = c.diffuse.rgb * decoRGBE(textureCubeLodEXT(u_diffuse, c.R, lod)) * diffuseIntensity;\n        vec3 indirectDiff = c.diffuse.rgb * decoRGBE(textureLod(u_diffuse, c.R, lod)) * diffuseIntensity;\n    #else\n        vec3 indirectDiff = c.diffuse.rgb * decoRGBE(texture(u_diffuse, c.R)) * diffuseIntensity;\n    #endif\n\n    //照明合并\n    vec3 finalColor = directL + indirectSpec + indirectDiff;\n    // vec3 finalColor = c.N;\n\n#ifdef LIGHTMAP\n    //有lightMap 时，用lightmap 贡献一部分 间接光照\n    vec4 lightmap = texture(_LightmapTex, lightmap_TEXCOORD);\n    vec3 lightMapColor;\n    if(glstate_lightmapRGBAF16 == 1.0){\n        // finalColor.xyz *= lightmap.xyz;\n        lightMapColor = sRGBtoLINEAR(lightmap).rgb;\n    }else{\n        // finalColor.xyz *= decode_hdr(lightmap);\n        lightMapColor = decode_hdr(lightmap);\n    }\n\n    // finalColor += c.diffuse.rgb * lightMapColor;\n    finalColor += c.diffuse.rgb * lightMapColor * diffuseIntensity;\n#endif\n\n    //emission\n    finalColor += sRGBtoLINEAR(texture(uv_Emissive, xlv_TEXCOORD0 * uvRepeat)).rgb * CustomEmissiveColor.rgb;\n    \n    //AO + Exposure\n    finalColor *= u_Exposure * texture(uv_AO, xlv_TEXCOORD0 * uvRepeat).r;\n\n\n    //色调映射 （HDR -> LDR）\n    finalColor = toneMapACES(finalColor);\n\n#ifdef FOG\n    finalColor.xyz = mix(glstate_fog_color.rgb, finalColor.rgb, factor);\n#endif\n\n    // color = vec4(finalColor, c.diffuse.a);\n    color = vec4(finalColor, c.diffuse.a);\n}","pbr.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"alphaCutoff('alphaCutoff',Range(0.0,1.0))= 0.0\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"uv_Emissive('Emissive',Texture)='white'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\",\n        \"CustomEmissiveColor ('EmissiveColor', Color) = (0,0,0,1)\",\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","pbr.vs.glsl":"#version    300 es\r\n\r\nlayout(location = 0) in highp vec3    _glesVertex;\r\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\r\nlayout(location = 1) in highp vec3    _glesNormal;\r\nlayout(location = 2) in highp vec3    _glesTangent;\t//w 被乘到了分量里 x = x*w , y = y*w , z = z*w , 且 w 被做了 +2 的偏移映射。\r\nlayout(location = 3) in highp vec3    _glesColor;\r\n\r\nuniform highp mat4      glstate_matrix_mvp;\r\nuniform highp mat4      glstate_matrix_model;\r\nuniform highp mat4      glstate_matrix_it_modelview;\r\n\r\nout highp vec3      v_pos;\r\nout highp vec2      xlv_TEXCOORD0;\r\nout highp mat3\t\tTBN;\r\n\r\n#ifdef LIGHTMAP\r\nlayout(location = 5) in mediump vec2 _glesMultiTexCoord1;\r\nuniform lowp float glstate_lightmapUV;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\nout mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nmat4 blendMat ;\r\nlayout(location = 6) in lowp vec4    _glesBlendIndex4;\r\nlayout(location = 7) in mediump vec4    _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat* srcVertex;\r\n}\r\n#endif\r\n\r\n//获取 tangent 的 W 值\r\nlowp float tangentW(lowp vec3 _tangent){\r\n\treturn sqrt(_tangent.x * _tangent.x + _tangent.y * _tangent.y + _tangent.z * _tangent.z) - 2.0;\r\n}\r\n\r\n//计算 TBN 矩阵-----------------\r\nmat3 calTBNMatrix(highp mat4 _m_mat,lowp vec3 _normal,lowp vec3 _tangent)\r\n{\r\n\r\n    vec3 normal = normalize(mat3(_m_mat) * normalize(_normal));\r\n    vec3 tangent = normalize(mat3(_m_mat) * normalize(_tangent));\r\n    vec3 binormal = cross( normal , tangent) * tangentW(_tangent);\r\n  \treturn mat3(tangent,binormal,normal);\r\n}\r\n//-----------------------------\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n    //求世界空间法线\r\n#ifdef SKIN\r\n    vec3 _n = normalize(mat3(blendMat) * _glesNormal);\r\n#else\r\n    vec3 _n = _glesNormal;\r\n#endif\r\n\tTBN = calTBNMatrix(glstate_matrix_it_modelview , _n , _glesTangent);\r\n}\r\n\r\nvoid main () {\r\n    highp vec4 position = vec4(_glesVertex,1.0);\r\n\r\n#ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = (1.0 - glstate_lightmapUV) * _glesMultiTexCoord0  + glstate_lightmapUV * _glesMultiTexCoord1;\t//unity lightMap UV ,优先使用UV1,次之UV0 \r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n#endif\r\n\r\n#ifdef SKIN\r\n    position = calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n#endif\r\n\t//normal\r\n\tcalcNormal(position);\r\n\t//world pos\r\n    vec4 wpos\t\t= (glstate_matrix_model * position);\r\n\tv_pos\t\t\t= wpos.xyz / wpos.w;\r\n    //texcoord\r\n\txlv_TEXCOORD0   = _glesMultiTexCoord0;\r\n\r\n\t// // TBN\r\n    // vec3 N        \t= normalize((glstate_matrix_it_modelview * vec4(_glesNormal, 0.0)).xyz);\r\n\t// vec3 tangent \t= normalize((glstate_matrix_it_modelview * vec4(_glesTangent, 0.0)).xyz);\r\n\t// vec3 bitangent \t= cross(N, tangent) * tangentW(_glesTangent);// * _glesTangent.w;\r\n\t// TBN = mat3(tangent, bitangent, N);\r\n\t// TBN = calTBNMatrix(glstate_matrix_it_modelview , _glesNormal , _glesTangent);\r\n\r\n\tposition = glstate_matrix_mvp * position;\r\n\r\n#ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n#endif\r\n\r\n    gl_Position\t= position;\r\n}","pbr_2sided.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"alphaCutoff('alphaCutoff',Range(0.0,1.0))= 0.0\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"uv_Emissive('Emissive',Texture)='white'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\",\n        \"CustomEmissiveColor ('EmissiveColor', Color) = (0,0,0,1)\",\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","pbr_blend.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"alphaCutoff('alphaCutoff',Range(0.0,1.0))= 0.0\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"uv_Emissive('Emissive',Texture)='white'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\",\n        \"CustomEmissiveColor ('EmissiveColor', Color) = (0,0,0,1)\",\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","pbr_blend_2sided.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"alphaCutoff('alphaCutoff',Range(0.0,1.0))= 0.0\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"uv_Emissive('Emissive',Texture)='white'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\",\n        \"CustomEmissiveColor ('EmissiveColor', Color) = (0,0,0,1)\",\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\": \"off\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","sence01pubu.fs.glsl":"#version 300 es\r\n\r\nprecision lowp float;\r\nuniform lowp sampler2D _R;\r\nuniform lowp sampler2D _G;\r\nuniform lowp sampler2D _B;\r\n\r\nuniform lowp float _RClose;\r\nuniform lowp float _GClose;\r\nuniform lowp float _BClose;\r\n\r\nuniform lowp vec4 _Rcolor;\r\nuniform lowp vec4 _Gcolor;\r\nuniform lowp vec4 _Bcolor;\r\n\r\n\r\n//in-------------------------\r\nin mediump vec2 uv_R_TEXCOORD;\r\nin mediump vec2 uv_G_TEXCOORD;\r\nin mediump vec2 uv_B_TEXCOORD;\r\nin mediump float v_color_a;\r\n\r\n//--------------------------------\r\n\r\n//textureEtC1Mark\r\n\r\n#define lerp(a, b, v)   (a) * (1.0 - (v)) + (b) * (v) \r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nin lowp float factor;\r\n#endif\r\n\r\n\r\nout vec4 color;\r\nvoid main()\r\n{\r\n    lowp float _tempf = 2.0;\r\n    highp float _RClose_var = lerp( texture( _R , uv_R_TEXCOORD).r, 0.0, _RClose );\r\n    highp float _GClose_var = lerp( texture( _G , uv_G_TEXCOORD).g, 0.0, _GClose );\r\n    highp float _BClose_var = lerp( texture( _B , uv_B_TEXCOORD).b, 0.0, _BClose );\r\n    lowp vec3 finalColor = ((_RClose_var*_Rcolor.rgb*_Rcolor.a*_tempf)+(_GClose_var*_Gcolor.rgb*_Gcolor.a*_tempf)+(_BClose_var*_Bcolor.rgb*_Bcolor.a*_tempf));\r\n    lowp vec4 emission = vec4(finalColor , ((_RClose_var + _GClose_var + _BClose_var) * v_color_a));\r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    color = emission;\r\n}","sence01pubu.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_RS ('RS', Range(0, 1)) = 0\",\n        \"_GS ('GS', Range(0, 1)) = 0\",\n        \"_BS ('BS', Range(0, 1)) = 0\",\n        \"_RClose ('RClose', Float ) = 0\",\n        \"_Gclose ('Gclose', Float ) = 0\",\n        \"_Bclose ('Bclose', Float ) = 0\",\n        \"_Rcolor ('Rcolor', Color) = (0.5,0.5,0.5,1)\",\n        \"_Gcolor ('Gcolor', Color) = (0.5,0.5,0.5,1)\",\n        \"_Bcolor ('Bcolor', Color) = (0.5,0.5,0.5,1)\",\n        \"_R ('R', Texture) = 'white' {}\",\n        \"_G ('G', Texture) = 'white' {}\",\n        \"_B ('B', Texture) = 'white' {}\",\n        \"_R_ST('_R_ST',Vector) = (1,1,0,0)\",\n        \"_G_ST('_G_ST',Vector) = (1,1,0,0)\",\n        \"_B_ST('_B_ST',Vector) = (1,1,0,0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"showface\": \"ccw\",\n                \"vs\": \"sence01pubu\",\n                \"fs\": \"sence01pubu\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"showface\": \"ccw\",\n                \"vs\": \"sence01pubu\",\n                \"fs\": \"sence01pubu\"\n            }\n        ]\n    }\n}","sence01pubu.vs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec4 _glesVertex;\r\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\r\nlayout(location = 3) in lowp vec4 _glesColor;\r\n\r\nuniform float glstate_timer;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _R_ST;\r\nuniform mediump vec4 _G_ST;\r\nuniform mediump vec4 _B_ST;\r\n\r\nuniform mediump float _RS;\r\nuniform mediump float _GS;\r\nuniform mediump float _BS;\r\n\r\n//varing ---------\r\nout mediump vec2 uv_R_TEXCOORD;\r\nout mediump vec2 uv_G_TEXCOORD;\r\nout mediump vec2 uv_B_TEXCOORD;\r\nout mediump float v_color_a;\r\n\r\n//----------------\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n\tlowp float timeScale = 1.0;\r\n\tv_color_a = _glesColor.a;\r\n    uv_R_TEXCOORD = (_glesMultiTexCoord0 + (timeScale * glstate_timer * _RS) * vec2(0.0,-1.0)) * _R_ST.xy + _R_ST.zw;\r\n    uv_G_TEXCOORD = (_glesMultiTexCoord0 + (timeScale * glstate_timer * _GS) * vec2(0.0,-1.0)) * _G_ST.xy + _G_ST.zw;\r\n    uv_B_TEXCOORD = (_glesMultiTexCoord0 + (timeScale * glstate_timer * _BS) * vec2(0.0,-1.0)) * _B_ST.xy + _B_ST.zw;\r\n\r\n    highp vec4 position = vec4(_glesVertex.xyz,1.0);\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n    gl_Position = position;\r\n}","simple.fs.glsl":"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D _MainTex;\nuniform float _AlphaCut;\nuniform vec4 _MainColor;\n\nin vec2 xlv_TEXCOORD0;    \n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nin lowp float factor;\n#endif\n\nout vec4 color; \nvoid main() \n{\n    vec4 basecolor = texture(_MainTex, xlv_TEXCOORD0);\n\n    if(basecolor.a < _AlphaCut)\n        discard;\n\n    basecolor = basecolor * _MainColor;\n\n    #ifdef FOG\n    basecolor.xyz = mix(glstate_fog_color.rgb, basecolor.rgb, factor);\n    #endif\n        \n    color = basecolor;\n}","simple.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.1\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ]\n    }\n}","simple.vs.glsl":"#version 300 es\n\nprecision highp float;\n\nlayout(location = 0) in highp vec3    _glesVertex;\nlayout(location = 4) in vec4 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\nuniform vec4 _MainTex_ST;\n\nout lowp vec2 xlv_TEXCOORD0;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\n#ifdef SKIN\nlowp mat4 blendMat ;\nlayout(location = 6) in lowp vec4    _glesBlendIndex4;\nlayout(location = 7) in mediump vec4    _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n\n#endif\n\nvoid main()\n{\n    vec4 position = vec4(_glesVertex.xyz,1.0);\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n\n    position = glstate_matrix_mvp * position;\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n    \n    gl_Position = position;\n}","simple_over.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.1\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"ztest\":\"off\",\n\t\t\t\t\"zwrite\":\"off\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ]\n    }\n}","skybox.fs.glsl":"#version 300 es\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\n#define PI          3.141592653589\r\n\r\nuniform samplerCube u_sky;\r\nuniform vec4        glstate_eyepos;\r\nuniform float       u_Exposure;\r\n\r\nin vec3        TexCoords;\r\n\r\nvec3 decoRGBE(vec4 r) {\r\n    if(r.a != 0.) {\r\n        float e = exp2(r.a * 255. - 128.);\r\n        return vec3(r.r * e, r.g * e, r.b * e);\r\n    }\r\n    return vec3(0);\r\n}\r\n\r\nvec3 toneMapACES(vec3 color) {\r\n    const float A = 2.51;\r\n    const float B = 0.03;\r\n    const float C = 2.43;\r\n    const float D = 0.59;\r\n    const float E = 0.14;\r\n    return pow(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0), vec3(1.0 / 2.2));\r\n}\r\n\r\nout vec4 color; \r\nvoid main () {\r\n    color = vec4(toneMapACES(u_Exposure * decoRGBE(texture(u_sky, TexCoords))), 1.0);\r\n}","skybox.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"zwrite\": \"off\",\r\n                \"ztest\":\"on\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"skybox\",\r\n                \"fs\": \"skybox\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"zwrite\": \"off\",\r\n                \"ztest\":\"on\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"skybox\",\r\n                \"fs\": \"skybox\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","skybox.vs.glsl":"#version 300 es\r\n\r\n//参考 https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/06%20Cubemaps/\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec3    _glesVertex;\r\n\r\nuniform highp mat4      glstate_matrix_view;\r\nuniform highp mat4      glstate_matrix_project;\r\n\r\nout highp vec3      TexCoords;\r\n\r\nvoid main () {\r\n    vec3 cubePos = _glesVertex * -2.0;  //因我们的 默认box mesh size为1, 需要加系数 -2.0\r\n    TexCoords   = cubePos;\r\n    vec4 pos =  glstate_matrix_project * mat4(mat3(glstate_matrix_view))  * vec4(cubePos, 1.0);\r\n    gl_Position = pos.xyww;\r\n}","sprite_bg.fs.glsl":"#version 300 es\n\nprecision highp float;\n\nuniform vec4 _Color;\nuniform vec4 _ChangeColor;\nuniform float _ChangeSize;\n\nin lowp vec2 uv;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nin lowp float factor;\n#endif\n\nout vec4 color;\nvoid main() \n{\n    float Diff = clamp((uv.y - _ChangeSize) * (uv.y - _ChangeSize) , 0.0 , 1.0) + clamp((1.0 - _ChangeSize) - uv.y , 0.0 , 1.0) * ((1.0 - _ChangeSize) - uv.y);\n    vec4 basecolor = _ChangeColor * Diff + (1.0 - Diff) * _Color;\n\n    #ifdef FOG\n    basecolor.xyz = mix(glstate_fog_color.rgb, basecolor.rgb, factor);\n    #endif\n        \n    color = basecolor;\n}","sprite_bg.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_Color ('Tint', Color) = (1,1,1,1)\",\n        \"_ChangeColor ('ChangeColor', Color) = (1,1,1,1)\",\n        \"_ChangeSize('ChangeSize',float) = 0.2\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\" : \"off\",\n                \"vs\": \"sprite_bg\",\n                \"fs\": \"sprite_bg\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"zwrite\" : \"off\",\n                \"vs\": \"sprite_bg\",\n                \"fs\": \"sprite_bg\"\n            }\n        ]\n    }\n}","sprite_bg.vs.glsl":"#version 300 es\n\nprecision highp float;\n\nlayout(location = 0) in vec4 _glesVertex;\nlayout(location = 4) in vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nout lowp vec2 uv;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\nvoid main()\n{\n    vec4 position = vec4(_glesVertex.xyz,1.0);\n\n    position = glstate_matrix_mvp * position;\n\n    uv = _glesMultiTexCoord0.xy;\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n    \n    gl_Position = position;\n}","t4diffuse.fs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nuniform lowp sampler2D _Splat0;\r\nuniform lowp sampler2D _Splat1;\r\nuniform lowp sampler2D _Splat2;\r\nuniform lowp sampler2D _Splat3;\r\nuniform lowp sampler2D _Control;\r\n\r\n//in-----------------------------\r\nin mediump vec2 s0_uv_TEXCOORD0;\r\nin mediump vec2 s1_uv_TEXCOORD1;\r\nin mediump vec2 s2_uv_TEXCOORD2;\r\nin mediump vec2 s3_uv_TEXCOORD3;\r\nin mediump vec2 c_uv_TEXCOORD4;\r\n\r\n//------------------------------------\r\n\r\n//textureEtC1Mark\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nin mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nin lowp float factor;\r\n#endif\r\n\r\n\r\nout vec4 color;\r\nvoid main()\r\n{\r\n    // lowp vec4 basecolor = texture(_MainTex, xlv_TEXCOORD0);\r\n    // if(basecolor.a < _AlphaCut)\r\n    //     discard;\r\n    // lowp vec4 fristColor = basecolor;\r\n    // lowp vec4 emission = fristColor;\r\n    lowp vec4 emission = vec4(.0,.0,.0,.0);\r\n\r\n    //----------------------------------------------------------\r\n    lowp vec4 splat_control = texture(_Control, c_uv_TEXCOORD4);\r\n    lowp float weight = dot(splat_control, vec4(1.0, 1.0, 1.0, 1.0));\r\n    splat_control /= (weight + 0.001);\r\n\r\n    lowp vec4 mixedDiffuse = vec4(.0,.0,.0,.0);\r\n    mixedDiffuse += splat_control.r * texture(_Splat0, s0_uv_TEXCOORD0);\r\n    mixedDiffuse += splat_control.g * texture(_Splat1, s1_uv_TEXCOORD1);\r\n    mixedDiffuse += splat_control.b * texture(_Splat2, s2_uv_TEXCOORD2);\r\n    mixedDiffuse += splat_control.a * texture(_Splat3, s3_uv_TEXCOORD3);\r\n    emission = vec4(mixedDiffuse.xyz , weight);\r\n\r\n    #ifdef LIGHTMAP\r\n        lowp vec4 lightmap = texture(_LightmapTex, lightmap_TEXCOORD);\r\n        emission.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n    #ifdef FOG\r\n        emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    color = emission;\r\n}","t4diffuse.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_Control ('Control (RGBA)', Texture) = 'white' {}\",\n\t\t\"_Splat0 ('Layer 1', Texture) = 'white' {}\",\n\t\t\"_Splat1 ('Layer 2', Texture) = 'white' {}\",\n\t\t\"_Splat2 ('Layer 3', Texture) = 'white' {}\",\n        \"_Splat3 ('Layer 4', Texture) = 'white' {}\",\n\n        \"_Splat0_ST('Splat0_ST',Vector) = (1,1,0,0)\",\n        \"_Splat1_ST('Splat1_ST',Vector) = (1,1,0,0)\",\n        \"_Splat2_ST('Splat2_ST',Vector) = (1,1,0,0)\",\n        \"_Splat3_ST('Splat3_ST',Vector) = (1,1,0,0)\",\n        \"_Control_ST('Control_ST',Vector) = (1,1,0,0)\"\n        \n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse\",\n                \"fs\": \"t4diffuse\"\n            }\n        ]\n    }\n}","t4diffuse.vs.glsl":"#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in highp vec4 _glesVertex;\r\nlayout(location = 4) in mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _Splat0_ST;\r\nuniform mediump vec4 _Splat1_ST;\r\nuniform mediump vec4 _Splat2_ST;\r\nuniform mediump vec4 _Splat3_ST;\r\nuniform mediump vec4 _Control_ST;\r\n\r\n//light\r\nlowp mat4 blendMat ;\r\nlayout(location = 1) in lowp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\n\r\n//varing--------------\r\nout mediump vec2 s0_uv_TEXCOORD0;\r\nout mediump vec2 s1_uv_TEXCOORD1;\r\nout mediump vec2 s2_uv_TEXCOORD2;\r\nout mediump vec2 s3_uv_TEXCOORD3;\r\nout mediump vec2 c_uv_TEXCOORD4;\r\n//---------------------\r\n\r\n#ifdef LIGHTMAP\r\nlayout(location = 5) in mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nout mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nout lowp float factor;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    s0_uv_TEXCOORD0 = _glesMultiTexCoord0.xy * _Splat0_ST.xy + _Splat0_ST.zw;\r\n    s1_uv_TEXCOORD1 = _glesMultiTexCoord0.xy * _Splat1_ST.xy + _Splat1_ST.zw;\r\n    s2_uv_TEXCOORD2 = _glesMultiTexCoord0.xy * _Splat2_ST.xy + _Splat2_ST.zw;\r\n    s3_uv_TEXCOORD3 = _glesMultiTexCoord0.xy * _Splat3_ST.xy + _Splat3_ST.zw;\r\n    c_uv_TEXCOORD4  = _glesMultiTexCoord0.xy * _Control_ST.xy + _Control_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","t4diffuse_use_uv1.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_Control ('Control (RGBA)', Texture) = 'white' {}\",\n\t\t\"_Splat0 ('Layer 1', Texture) = 'white' {}\",\n\t\t\"_Splat1 ('Layer 2', Texture) = 'white' {}\",\n\t\t\"_Splat2 ('Layer 3', Texture) = 'white' {}\",\n        \"_Splat3 ('Layer 4', Texture) = 'white' {}\",\n\n        \"_Splat0_ST('Splat0_ST',Vector) = (1,1,0,0)\",\n        \"_Splat1_ST('Splat1_ST',Vector) = (1,1,0,0)\",\n        \"_Splat2_ST('Splat2_ST',Vector) = (1,1,0,0)\",\n        \"_Splat3_ST('Splat3_ST',Vector) = (1,1,0,0)\",\n        \"_Control_ST('Control_ST',Vector) = (1,1,0,0)\"\n        \n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse_use_uv1\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse_use_uv1\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse_use_uv1\",\n                \"fs\": \"t4diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"t4diffuse_use_uv1\",\n                \"fs\": \"t4diffuse\"\n            }\n        ]\n    }\n}","t4diffuse_use_uv1.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec4 _glesVertex;\nlayout(location = 4) in mediump vec2 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Splat0_ST;\nuniform mediump vec4 _Splat1_ST;\nuniform mediump vec4 _Splat2_ST;\nuniform mediump vec4 _Splat3_ST;\nuniform mediump vec4 _Control_ST;\n\n//light\nlowp mat4 blendMat ;\nlayout(location = 1) in lowp vec3 _glesNormal;\nuniform highp mat4 glstate_matrix_model;\n\n//varing--------------\nout mediump vec2 s0_uv_TEXCOORD0;\nout mediump vec2 s1_uv_TEXCOORD1;\nout mediump vec2 s2_uv_TEXCOORD2;\nout mediump vec2 s3_uv_TEXCOORD3;\nout mediump vec2 c_uv_TEXCOORD4;\n//---------------------\n\n#ifdef LIGHTMAP\nlayout(location = 5) in mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nout mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\nvoid main()\n{\n    s0_uv_TEXCOORD0 = _glesMultiTexCoord0.xy * _Splat0_ST.xy + _Splat0_ST.zw;\n    s1_uv_TEXCOORD1 = _glesMultiTexCoord0.xy * _Splat1_ST.xy + _Splat1_ST.zw;\n    s2_uv_TEXCOORD2 = _glesMultiTexCoord0.xy * _Splat2_ST.xy + _Splat2_ST.zw;\n    s3_uv_TEXCOORD3 = _glesMultiTexCoord0.xy * _Splat3_ST.xy + _Splat3_ST.zw;\n    c_uv_TEXCOORD4  = _glesMultiTexCoord0.xy * _Control_ST.xy + _Control_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord0.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","transparent.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform lowp sampler2D _MainTex;                                                                                                \nin highp vec2 xlv_TEXCOORD0;\nuniform lowp float _Alpha;\nuniform lowp float _Superimposition;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nin lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\nout vec4 color; \nvoid main() \n{\n    lowp vec4 emission = texture(_MainTex, xlv_TEXCOORD0);\n    emission.a=emission.a*_Alpha;\n    emission.xyz *= _Superimposition;\n    //----------------------------------------------------------\n    #ifdef FOG\n    emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\n    #endif\n    color = emission;\n\n}","transparent.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","transparent.vs.glsl":"#version 300 es\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec3    _glesVertex;\nlayout(location = 4) in mediump vec4    _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n\nout mediump vec2 xlv_TEXCOORD0;\n\n#ifdef INSTANCE\n//instance_matrix 固定地址\nlayout(location = 12) in highp mat4 instance_matrix;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nout lowp float factor;\n#endif\n\n#ifdef SKIN\nlayout(location = 6) in lowp vec4    _glesBlendIndex4;\nlayout(location = 7) in mediump vec4    _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    //----------------------------------------------------------\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n\n\t#ifdef INSTANCE\n        position = instance_matrix * position;\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    gl_Position = position;\n}","transparent_particles_standard.fs.glsl":"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D _MainTex;\n\nuniform vec4 u_color;\n\nuniform float EXTENDED_PARTICLES;\nuniform float _EmissionSaturation;\nuniform float _OpacitySaturation;\nuniform float _ColorMultiplier;\n\nuniform float COLOR_RAMP;\nuniform sampler2D _ColorRamp;\nuniform vec4 _ColorRamp_ST;\nuniform float COLOR_TINT;\nuniform vec4 _BasicColor;\nuniform vec4 _SaturatedColor;\n\nuniform float DISSOLVE_ENABLED;\nuniform vec4 _DissolveStep;\n\nuniform float NOISE_TEXTURE;\nuniform sampler2D _NoiseTex;\nuniform vec4 _TintColor;\n\nuniform float EMISSIVEPOWER;\nuniform float _EmissivePower;\n\nuniform float _ABOffset;\n\nuniform float _GlobalAlpha;\n\nin vec2 v_uv;\nin vec4 v_color;\n\nin vec2 v_particledata;\nin vec2 v_noiseuv;\n\nuniform float APPLY_RGB_COLOR_VERTEX;\nuniform float NOISE_TEXTURE_EMISSION;\nuniform float NOISE_TEXTURE_ALPHA;\nuniform float NOISE_TEXTURE_DISSOLVE;\n\nuniform float BlendMode;\n\nout vec4 color; \nvoid main() \n{\n    vec4 tex = texture(_MainTex, v_uv);\n\n    vec4 col = vec4(1.0, 1.0, 1.0, 1.0);\n\n    vec4 vcolor = vec4(1.0, 1.0, 1.0, v_color.w);\n\n    if( EXTENDED_PARTICLES > 0.5 )\n    {\n        if( APPLY_RGB_COLOR_VERTEX > 0.5)\n        {\n            vcolor = v_color;\n        }\n\n        float nEmission = 1.0;\n        float nAlpha = 1.0;\n        float nDissolve = 1.0;\n        \n        if( NOISE_TEXTURE > 0.5)\n        {\n            vec3 noise = texture(_NoiseTex, v_noiseuv).xyz;\n        \n            if( NOISE_TEXTURE_EMISSION > 0.5)\n            {\n                nEmission = noise.x;\n            }\n            else\n            {\n                nEmission = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_ALPHA > 0.5)\n            {\n                nAlpha = noise.y;\n            }\n            else\n            {\n                nAlpha = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_DISSOLVE > 0.5)\n            {\n                nDissolve = noise.z;\n            }\n            else\n            {\n                nDissolve = 1.0;\n            }\n        }\n    \n        if( DISSOLVE_ENABLED > 0.5)\n        {\n            float ramp = -1.0 + (v_particledata.x * 2.0);\n            col.a = clamp(tex.g * smoothstep(_DissolveStep.x, _DissolveStep.y, (tex.b + ramp) * nDissolve) * _OpacitySaturation * vcolor.w * nAlpha, 0.0, 1.0);\n        }\n        else\n        {\n            col.a = clamp(tex.g * _OpacitySaturation * vcolor.w, 0.0, 1.0) * nAlpha;\n        }\n    \n        float lerpValue = 0.0;\n        if(COLOR_TINT < 0.5)\n        {\n            lerpValue = clamp(tex.r * v_particledata.y * _ColorMultiplier * nEmission, 0.0, 1.0);\n        }\n    \n        if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5)\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * _EmissionSaturation;\n                }\n            }\n            col.a *= _GlobalAlpha;\n        }\n        else\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * col.a * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5 )\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation * col.a;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * col.a * _EmissionSaturation;\n                }\n            }\n            col *= _GlobalAlpha;\n        }\n    }\n    else\n    {\n        if( 3.5 < BlendMode && BlendMode < 4.5 ) //4\n        {\n            tex *= _TintColor;\n            float luminance = clamp(dot(tex, vec4(0.2126, 0.7152, 0.0722, 0.0)) * tex.a * _ABOffset, 0.0, 1.0);\n            vec4 one = vec4(1, 1, 1, 1);\n            col = mix(2.0 * (v_color * tex), one - 2.0 * (one - v_color) * (one - tex), luminance);\n        }\n        else\n        {\n            col = v_color * tex;\n            col *= _TintColor;\n        \n            if( EMISSIVEPOWER > 0.5)\n            {\n                col *= _EmissivePower;\n            }\n            \n            if( 0.5 < BlendMode && BlendMode < 1.5 ) //1\n            {\n                col.rgb *= col.a;\n            }\n            else\n            {\n                if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n                {\n                    col *= 2.0;\n                }\n                else\n                {\n                    if( 1.5 < BlendMode && BlendMode < 2.5 ) //2\n                    {\n                        col *= 4.0;\n                    }\n                }\n            }\n        }\n    \n        col *= _GlobalAlpha;\n\n    }\n\n    color = col;\n}","transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"transparent_particles_standard\",\n        \"fs\": \"transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"transparent_particles_standard\",\n        \"fs\": \"transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","transparent_particles_standard.vs.glsl":"#version 300 es\n\n\nprecision mediump float;\n\nlayout(location = 0) in highp vec3    _glesVertex;\nlayout(location = 4) in vec2 _glesMultiTexCoord0;\nlayout(location = 3) in vec4 _glesColor;\n\nuniform vec4 _MainTex_ST;\n\nuniform vec4 _Panning;\nuniform float glstate_timer;\n\nuniform vec4 _NoiseTex_ST;\nuniform vec4 _NoisePanning;\n\nuniform mat4 glstate_matrix_mvp;\n\nout vec2 v_uv;\nout vec4 v_color;\n\nuniform float EXTENDED_PARTICLES;\nout vec2 v_particledata;\n\nuniform float NOISE_TEXTURE;\nuniform float NOISEUV;\nout vec2 v_noiseuv;\n\nvoid main() \n{\n    vec3 position = _glesVertex;\n    gl_Position = glstate_matrix_mvp * vec4(position, 1.0);\n    v_uv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_Panning.xy * glstate_timer);\n    v_color = _glesColor;\n    // v_color = vec4(1.0,1.0,1.0,1.0);\n\n    if(EXTENDED_PARTICLES > 0.5)\n    {\n        if( NOISE_TEXTURE > 0.5)\n        {\n            if( NOISEUV > 0.5)\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _NoiseTex_ST.xy + _NoiseTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n            else\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n        }\n    }\n    else\n    {\n        // v_particledata = _glesMultiTexCoord0.zw;\n        v_particledata = _glesMultiTexCoord0;\n    }\n}"}